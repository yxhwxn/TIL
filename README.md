# Today I Learned 📕📗📘

# 알고리즘의 분석

- 정확성 분석: 모든 사례에 대해 정확한 해답을 찾는다는 것을 증명(귀납적 증명)
- 효울성 분석: **시간 복잡도**, 공간 복잡도
    
    → 어떠한 문제에 대한 해답을 찾는 것이 알고리즘인데, 여기서 퍼포먼스를 측정하는 것은 컴퓨터의 성능이나 프로그래밍 언어에 따라 달라질 수 있다
    
    → 그래서 입력 크기에 따른 단위 연산의 실행 횟수를 세는 **복잡도 분석을 함으로써 알고리즘의 성능을 분석할 수 있다 !! ⇒ 단위 연산을 몇 번 하느냐 !**
    

# 복잡도 분석(시간 복잡도 = 단위 연산을 몇번 하는지 구하기)

- 입력 크기: 문제가 가진 파라미터, 입력 사례의 크기 ⇒ n
- **단위 연산**을 몇 번하는지 봐보자 !

## 알고리즘(행렬 곱셈)

- 단위연산의 실행 횟수는 항상 일정한가?
    
    → 일정하지 않다
    
    ex) 순차 탐색의 경우 입력사례에 따라 실행 횟수가 달라진다(찾고자 하는 값이 앞쪽에 있으면 더 짧은 실행 횟수를 가짐)
    
    따라서, 입력 사례에 따른 시간 복잡도를 분석하는 것이 중요해진다
    
    - 입력 사례에 따른 시간 복잡도 분석
        - **일정** 시간 복잡도: 위에서 봤던 배열의 합, 교환정렬, 행렬 곱셈
        - 최악, 최적, 평균 시간 복잡도 분석
            
            → 보통 알고리즘의 시간 복잡도를 분석할 때는, **최악의 경우**가 중요하다.
            
# 알고리즘의 차수

- 차수 ⇒ 어떤 알고리즘이 (궁극적으로) 더 빠른가? 에 대한 해결
    - 차수(Order): 알고리즘의 궁극적인 성능 분류
- f1보다 f2의 차수가 더 크다? ⇒ (궁극적으로) f1이 f2보다 빠른 알고리즘이다.
- **시간 복잡도 함수의 차수**로 알고리즘의 성능을 분류할 수 있다.

![Untitled](https://github.com/yxhwxn/TIL/assets/87745916/d4dd4a12-4748-4b52-b2c7-77d73a83a59a)

→ 주로 봐야할 것은 “n < nlgn”, “2^n < n!”

- 점근적 표기법(궁극적으로는 이 알고리즘은 시간 복잡도의 제일 높은 차수에 수렴하더라 !)
    
    - 빅오: 점근적 상한
        
        → O(n^2): 이 알고리즘은 적어도 n^2보다 작거나 같아 !
        
        → 알고리즘의 관점에서 보면 정렬 알고리즘의 최악의 경우는 언제인가? → 이것에 대한 답변 가능
        
        ex. 정렬 알고리즘은 적어도 f(n)보다 작거나 같아.(f(n)이 최악의 경우야, 가장 오래걸려)
        
    - 오메가: 점근적 하한
        
        → 얜 적어도 n^2보다 작아지지 않아 / n^2보다 항상 크거나 같아
        
        → 문제 해결의 관점에서 보면 정렬 알고리즘이 가장 빠르게 해결할 수 있을 때가 언제냐?
        
        ex. 정렬 알고리즘이 오메가f(n)일때, 가장 빨라. f(n)보다 빠를 순 없어.
        
    - 세타: 차수 / 상한과 하한을 모두 만족함
